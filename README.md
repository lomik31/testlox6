# **шпаргалка по git**

## **ОБЩИЕ СИМВОЛЫ**

* ### __ТИЛЬДА (~):__
	* __коммит~:__ родитель коммита
	* __коммит~~:__ родитель родителя коммита
	* __коммит~3:__ коммит, предшествуюущий коммиту ~~
      -  чем больше тильд, тем более ранний коммит мы имеем ввиду по нашей ветке вниз.
      - чтобы не писать много тильд, заменяем их на цифры: ~~ = ~2; ~~~ = ~3; и так далее

* ### __СОБАЧКА(@) = HEAD__

---

## **ОБЩИЕ ФЛАГИ**

-f: принудительное действие, в обход предупреждения\
--cashed: применить действие не к файлам рабочей директории, а к index

---

### **GIT ADD**

* add .: добавить в index все изменения текущей директории

* add -A: добавить в index все изменения, начиная с корня проекта

* add -p: для каждого измененного участка файла выбрать, что делать с ним — добавить в index или нет
### **GIT COMMIT**

* commit -v: отображает изменения, которые попадут в новый коммит

* commit -m “текст”: создать коммит с комментарием одной строкой

* commit --all (-a): добавить все изменения в индекс и создать коммит 
    - игнорирует неотслеживаемые файлы

* commit [название файла, папки]: сделать коммит только необходимых файлов из рабочей директории или из index , даже если есть изменения в index
    - игнорирует неотслеживаемые файлы

* commit -c <коммит>: скопировать название, описание, автора и дату из существующего коммита
    - после выполнения откроется редактор, в котором можно будет отредактировать эти данные

* commit -C <коммит>: скопировать название, описание, автора и дату из существующего коммита без редактирования
    - --reset-author: возьмет из коммита название и описание, а автора и дату сгенерирует заново

* commit --amend: редактировать последний коммит, заменяя его файлами из index
    - по сути выполняется reset --soft а затем создается новый коммит с возможностью редактировать описание

	- commit --reset-author: генерирует информацию об авторе заново (см. commit -C)

	- commit --no-edit: отменяет открытие редактора, информация о коммите скопируется из последнего коммита

### **GIT RM: удаление файлов и добавление этого изменения в index**
* rm <название файла>

* rm -r <название папки>: рекурсивное удаление файлов в папке, удаление всех вложенных файлов

* rm --cashed: удаление файлов из index, но сохранение в рабочей директории

* rm -f: принудительно удалить файлы, даже в которых были внесены изменения

### **GIT MV: перемещение файла**
- можно использовать для переименования
- перемещает файл и добавляет изменение в index

### **GIT BRANCH: посмотреть все ветки проекта**

* branch [название ветки]: создать новую ветку

* branch [название ветки] [хэш коммита]: создать новую ветку на нужном коммите

* branch -f: принудительно создать ветку, если уже существует, переместить на указанное место (по умолчанию HEAD)
    - невозможно переместить текущую ветку, для перемещения, необходимо перейти на другую ветку

* branch -v: посмотреть более подробную информацию — хэш и название последнего коммита на ветках

* branch -d <название ветки>: удаляет указанную ветку
    - при удалении ветки, коммиты сделанные в ней, остаются
    - сработает в том случае, если текущая ветка и удаляемая были объединены (указывают на один коммит)

* branch -D <название ветки>: удалить указанную ветку, даже если там есть коммиты, участвующие в той ветке
    - коммиты, сделанные в ней также остаются, но через некоторое время будут удалены, если они не будут принадлежать какой-нибудь ветке

### **GIT CHECKOUT**
    - незакомиченные изменения можно переносить между ветками в случае, если эти файлы в обоих ветках не отличаются

* checkout <название ветки/хэш коммита>: переключение на существующую ветку/коммит

* checkout [хэш коммита] [названия файлов]: копирование из нужного коммита необходимых файлов в текущую ветку и добавление их в index
    - можно использовать в качестве хэша HEAD. в таком случае изменения в файлах и index перепишутся версией из HEAD
    - в случае, если хэш не указан, в рабочей директории файлы перезапишутся версиями из index

* checkout -b <название веки>: создать ветку и переключиться на неё. если существует, произойдет просто переключение

* checkout -B <название ветки> [хэш коммита]: создать ветку на нужном комитте и переключиться на неё. если существует, переместить на указанный коммит и переключиться

* checkout -f [название ветки] [название файла]: принудительное переключение на ветку, даже если есть незакомиченные изменения
    -  если название ветки не указано, будет произведено переключение на HEAD, т.е. все изменения просто перепишутся версией последнего коммита
    - не применяется к неотслеживаемым файлам

### **GIT SHASH: собирает все изменения, удаляет их из файлов рабочей директории и архивирует их**

* stash pop: вернуть сохраненные изменения обратно
    - изменения, сохраненные в одной ветке можно перенести в другую, использовав stash в одной ветке, а stash pop в другой

### **GIT RESET**

* reset (--mixed по умолчанию) [коммит] [названия файлов]: переместить текущую ветку на заданный коммит, сбросив также изменения в index, но сохранив в рабочей директории
    - если не указан коммит, по умолчанию будет HEAD, что просто сбросит index до состояния последнего коммита
    - если указан коммит и путь для файлов, файлы в index перезапишутся версиями из этого коммита, при этом сама ветка не передвинется

* reset --hard [коммит]: передвигает текущую ветку на необходимый коммит, перезаписывает файлы в рабочей директории и index версиями из этого коммита
    - если коммит не указан, по умолчанию принимается HEAD, по сути сбрасывая все изменения в index и рабочей директории на момент последнего коммита
    - при этом незакомиченные изменения навсегда пропадают
    - коммит, с которого мы перешли в новый, не удаляется, а исчезает сам через некоторое время
    - записывает предыдущее значение HEAD, с которого было произведено переключение в ORIG_HEAD

* reset --soft <коммит>: передвигает текущую ветку на необходимый коммит, сохраняя все изменения в index и рабочей директории
    - по сути, отменяет последний коммит, оставляя новые файлы в index и рабочей директории

### **GIT SHOW: показывает изменения в последнем коммите**

* show --quiet: показывает информацию о коммите за исключением изменений в нем

* show --pretty=fuller: показывает всю информацию о коммите

* show [хэш коммита/название ветки]: показывает изменения в интересующем коммите

* show [коммит]:<название файла> — показывает состояние файла на момент интересующего коммита

* show :<название файла> — показывает состояние файла в index

* show :/"слово или фраза из описания коммита" — показать самый последний коммит, содержащий в названии или описании искомое слово или фразу
    - кавычки не требуются, если поисковый запрос состоит из одного слова
    - помимо слова или фразы можно также использовать регулярное выражение
    - ищет кормит не из текущей ветки, а любой самый новый

### **GIT MERGE**

* merge <название ветки>
    - слиять необходимую ветку с текущей
    - после выполнения будет записано значение ORIG_HEAD, который будет указывать на коммит, который был в текущей ветке до слияния

### **GIT CLEAN: очистить (удалить) неотслеживаемые файлы в директории проекта**

* clean -f: необходима всегда при выполнении

* clean -d: удаление не только файлов, но и директорий

* clean -x: удаление файлов, которые добавлены в .gitignore